# 6장 데이터 타입

- **데이터 타입**
    
    값의 종류 (줄여서 타입이라고도 함)
    
    자바스크립트의 모든 값은 데이터 타입을 가짐
    
- **종류**
    
    7개의 데이터 타입을 제공함
    
    - **원시타입**
        - 숫자 타입
        - 문자열 타입
        - 불리언 타입
        - undefined 타입
        - null 타입
        - 심벌 타입 (ES6에서 추가된 타입)
    - **객체 타입**
        - 객체, 함수, 배열 등
- 개발자는 명확한 의도를 가지고 타입을 구별해서 값을 생성할 것이고, 자바스크립트 엔진은 타입을 구별해서 값을 취급할 것임

## 6.1 숫자 타입

- 하나의 숫자 타입만 존재함
    - ECMAScript 사양에 따르면 숫자타입의 값은 배정밀도 64비트 부동소수점 형식을 따름
        
        → 모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않음
        
        ```jsx
        var integer = 10; // 정수
        var double = 10.12; // 실수
        var negative = -10; // 음수
        ```
        
        → 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장됨
        
    - 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 떄문에 이들 값을 참조하면 모두 10진수로 해석됨
        
        ```jsx
        var binary = 0b1000001; // 2진수
        var octal = 0o101; // 8진수
        var hex = 0x41; // 16진수
        
        // 표기법만 다를 뿐 모두 같은 값
        console.log(binary); // 65
        console.log(octal); // 65
        console.log(hex); // 65
        console.log(binary === octal); // true
        console.log(hex === octal); // true
        ```
        
        →  정수로 표시된다 해도 사실은 실수임
        
        따라서 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있음
        
- 추가적으로 세 가지 특별한 값도 표현 가능
    - Infinity: 양의 무한대
    - -Infinity: 음의 무한대
    - NaN: 산술 연산 불가
        
        ⛔️ 자바스크립트는 대소문자를 구별하므로 NAN, Nan, nan과 같이 표현하면 에러남
        
    
    ```jsx
    console.log(10 / 0); // Infinity
    console.log(10 / -0); // -Infinity
    console.log(1 * 'String'); // NaN
    ```
    

## 6.2 문자열 타입

- 텍스트 데이터를 나타내는 데 사용함
    - 문자열은 0개 이상의 16비트 유니코드 문자의 집합으로 전 세계 대부분의 문자를 표현할 수 있음
- 작은 따옴표(’ ’), 큰 따옴표 (” “), 또는 백틱(` `, ES6)으로 텍스트를 감쌈
    - 가장 일반적인 것은 작은 따옴표
    - **다른 타입의 값과 달리 문자열을 따옴표로 감싸는 이유:**
        
        키워드나 식별자 같은 토큰과 구분하기 위해서
        
        따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자 같은 토큰으로 인식함
        
        따옴표로 감싸지 않으면 공백 문자도 포함시킬 수 없음
        
- 문자열은 원시타입
    
    → 변경 불가능한 값 (immutable)
    
    → 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미함
    

## 6.3 템플릿 리터럴

- ES6부터 템플릿 리터럴 (새로운 문자열 표기법) 도입
- **기능**
    
    문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공함
    
    템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리됨
    
- 백틱(` `)을 사용해 표현함

### 6.3.1 멀티라인 문자열

- 일반 문자열 내에서는 줄바꿈이 허용되지 않음
    
    → **일반 문자열 내에서 줄바꿈 등의 공백을 표현하기 위해서:**
    
    ⇒ 백슬래쉬(\)로 시작하는 **이스케이프 시퀀스** 사용해야함
    
    ![스크린샷 2023-07-16 오전 2.59.31.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d19f4875-1210-4488-9d96-abe46eb0add9/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_2.59.31.png)
    
- 일반 문자열과 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며, 모든 공백도 있는 그대로 적용됨

### 6.3.2 표현식 삽입

- 문자열은 문자열 연산자 `+`를 사용해 연결할 수 있음
- 템플릿 리터럴 내에서는 표현식 삽입을 통해 간단히 문자열을 삽입할 수 있음
    - 표현식을 삽입하려면 `${ }`으로 표현식을 감쌈
        
        → 표현식의 평가 결과가 문자열이 아니더라도 문자열로 타입이 강제로 변환되어 삽입됨
        
    - 반드시 탬플릿 리터럴 내에서만 사용해야함
        
        일반 문자열에서의 표현식 삽입은 문자열로 취급됨
        

## 6.4 불리언 타입

- 논리적 참, 거짓을 나타내는 true와 false뿐임

## 6.5 undefined 타입

- undefined가 유일함
- 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값
    - EX. var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화됨
    - 개발자가 의도적으로 할당하는 것은 본래 취지에서 어긋날뿐더러 혼란을 줄 수 있음
        
        → 변수에 값이 없다는 것을 명시하기 위해서 null 할당
        

> **➕ 선언과 정의**
> 
> 
> undefined를 직역하면 “정의되지 않은”이다.
> 
> 자바스크립트의 undefined에서 말하는 정의란 변수에 값을 할당하여 변수의 실체를 명확히 하는 것이다.
> 
> 변수를 선언하면 암묵적으로 정의가 이뤄지기 때문에 선언과 정의의 구분이 모호하다.
> ECMAScript 사양에서 변수는 “선언한다”라고 표현하고 함수는 “정의한다”라고 표현한다.
> 

## 6.6 null 타입

- null이 유일함
- 자바스크립트는 대소문자를 구별하므로 NULL, Null 등과는 다르다
- **사용**
    - null은 변수에 값이 없다는 것을 의도적으로 명시 (의도적 부재)할 때 사용함
        - 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않다는 의미임
        - 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것을 의미
        - 자바스크립트 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 컬렉션을 수행할 것임
    - 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 함
        - EX. `document.querySelector` 메서드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우 에러 대신 null을 반환함

## 6.7 심벌 타입

- ES6에서 추가된 7번째 타입
- 변경 불가능한 원시 타입의 값임
- 다른 값과 중복되지 않는 유일무이한 값
- **사용**
    - 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용함
    - 심벌 이외의 원시값은 리터럴을 통해 생성하지만 심벌은 `Symbol()`를 호출해 생성함
        
        이때 생성된 심벌값은 외부에 노출되지 않으며, **다른 값과 중복되지 않는 유일무이한 값**
        

## 6.8 객체 타입

- 자바스크립트는 객체 기반 언어
    
    → **자바스크립트를 이루고 있는 거의 모든 것이 객체**
    
    → 6.1 ~ 6.7 이외의 값은 모두 객체 타입
    

## 6.9 데이터 타입의 필요성

### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

- 값은 메모리에 저장하고 참조할 수 있어야함
    
    →  메모리 값을 저장하려면 확보해야할 메모리 공간의 크기를 결정해야 함
    
    몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지 알아야함
    
- **예시:**
    
    ```jsx
    var score = 100;
    ```
    
    - **값을 저장하는 경우:**
        1. 메모리 공간의 크기를 알아야함
            - 자바스크립트 엔진은 변수에 할당되는 값의 데이터 타입에 따라 정해진 크기의 메모리 공간을 확보함
        2. 컴퓨터는 숫자 값 100을 저장하기 위해 메모리 공간 확보
            - 리터럴 100을 숫자 타입으로 해석하고 숫자 값 100을 저장하기 위해 8 바이트의 메모리 공간 확보
        3. 값 100을 2진수로 저장
    - **값을 참조하는 경우:**
        1. 식별자 score를 통해 숫자 타입의 값 100이 저장되어 있는 메모리 공간의 주소를 찾아갈 수 있음
            - 메모리 공간의 선두 메모리 셀의 주소를 찾아가는 것임
        2. 값을 참조하기 위해서는 한 번에 읽어 들여야 할 메모리 공간의 크기 (메모리 셀의 개수 / 바이트 수)를 알아야 함
            - **HOW**
                
                변수에 숫자 타입의 값이 할당되어 있으므로 자바스크립트 엔진은  score 변수 자체를 숫자 타입으로 인식함
                
                → 숫자 타입 == 8바이트
                
        
        > **➕ 심벌 테이블**
        컴파일러 또는 인터프리터는 심벌 테이블이라고 부르는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리함
        > 

### 6.9.2 데이터 타입에 의한 값의 해석

- **메모리에서 읽어 들인 2진수는 어떻게 해석해야하나?**
    - **모든 값의 공통점:**
        - 데이터 타입을 가짐
        - 메모리 2진수로 저장됨
    - 메모리에 저장된 값은 데이터 타입에 따라서 다르게 해석될 수 있음
        - EX. 0100 0001
            
            → 숫자 타입 해석: 65
            
            → 문자열 해석: ‘A’
            
- **예제:**
    - score 변수에 할당된 값은 숫자 타입의 값
    - score 변수 참조시, 메모리 공간의 주소에서 읽어들인 2진수를 숫자로 해석함
- **데이터 타입이 필요한 이유:**
    - 값을 저장할 때 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해
    - 값을 참조할 때 한 번에 읽어 들여야 할 **메모리 공간의 크기**를 결정하기 위해
    - 메모리에서 읽어 들인 **2진수를 어떻게** 해석할지 결정하기 위해

## 6.10 동적 타이핑

### 6.10.1 동적 타입 언어와 정적 타입 언어

- 자바스크립트의 모든 값은 데이터 타입을 가짐
    
    → **그렇다면 변수는?**
    
    변수는 타입을 갖지 않음 
    
    하지만 값은 타입을 가짐
    
    따라서 현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정됨
    
    변수는 값에 묶여 있는 값에 대한 별명이기 때문에
    
- **정적 타입 언어:**
    - C / Java / 코틀린 / 고 / 하스켈 / 러스트 / 스칼라
    - **명시적 타입 선언:** 변수를 선언할 때 변수에 할당할 수 있는 값의 종류를 사전에 선언함
    - 변수의 타입을 변경할 수 없음
    - 변수 선언한 타입에 맞는 값만 할당할 수 있음
    - **타입 체크:** 컴파일 시점에 선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리
        - 만약 타입 체크 통과하지 못하면 에러 발생 및 프로그램 실행 막음
- **동적 타입 언어:**
    - 파이썬 / PHP / 루비 / 리스프 / 펄
    - 자바스크립트는 변수를 선언할 때 타입을 선언하지 않음 (var / let / const만 사용)
    - 미리 선언한 타입의 값만 할당할 수 있지 않음 어떠한 데이터 타입의 값이라도 자유롭게 할당 가능
    - **typeof 연산자**: 변수의 데이터 타입을 반환함
        - 정확히 말하면 **변수에 할당된 값의 데이터 타입**을 반환하는 것
- **차이점:**
    - **정적 타입 언어:** 변수 선언 시점에 변수의  타입이 결정되고 변수의 타입을 변경 불가
    - **동적 타입 언어:** 값을 할당하는 시점에 변수의 타입이 동적으로 결정되고 변수의 타입을 언제든지 자유롭게 변경 가능
        
        → **변수는 선언이 아닌 할당에 의해 타입이 결정되는 타입 추론이 됨, 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있음**
        

### 6.10.2 동적 타입 언어와 변수

- **동적 타입 언어:** 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있음
    - 데이터 타입에 대해 무감각해질 정도로 편리함
    - 편리함의 이면에는 위험이 도사리고 있음
- **단점:**
    - 변수 값은 언제든지 변경 가능하기 때문에 변화하는 변수 값을 추적하기 어려울 수 있음
    - 변수의 타입이 고정되어 있지 않고 동적으로 변하는 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있음
    - 따라서 동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없음
    - 유연성은 높지만 신회성이 떨어짐
- **변수 사용 시 주의 사항:**
    
    ![스크린샷 2023-07-17 오후 4.54.58.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/54190650-d24d-43ba-a940-ab680e580bd1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.54.58.png)
    
- **가독성 좋은 코드가 좋은 코드다**